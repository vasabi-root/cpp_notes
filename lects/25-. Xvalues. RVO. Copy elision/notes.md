# values
```
    gvalue    rvalue
     |  |      |  |
    /    \    /    \
lvalue   xvalue    prvalue
```

- `xvalue` -- expired value (просроченное) -- те, которые недавно были lvalue, но их мувнули (это объекты, реально лежащие в памяти): 
  - `func call -> rvalue`
  - обращение по индексу в rvalue-массиве
  - обращение к члену класса, экземпляр которого rvalue
  - `?:` с хотя бы одним возвращаемым выражением rvalue 
  - `ststic_cast<T&&>(x)`
- `prvalue` -- pure rvalue (чистое) -- все остальные rvalue (объекты, которые необязательно занимают место -- промежуточные объекты):
  - литералы 
  - temp materialization ???
- `glvalue` -- generalized lvalue:
  - может быть полиморфным типом: динамический тип объекта может не совпадать со статическим

# Incomplete type
- void
- массив неизвестного размера
- Объявленный, но не определённый, класс
- enum
- temp materialization ???

# Copy elision
```c++
template<typename T>
std::vector<T> f(T n) {
    return std::vector<T>(n);
}

int main() {
    // сколько раз вызовется конструктор?
    std::vector<int> v = std::vector<int>(10, 1); 
    // раньше мы бы сказали, что 2 раза: для `std::vector<int>(10, 1)` и копии для `v`
    // теперь мы знаем мув-семантику и понимаем, что вызовется мув-конструктор копии
    // хотя даже так вызывается 2 конструктора
    // но в реале даже этого не происходит
    // компилятор умеет (а с c++17, должен) такое оптимизировать
    // это и называется copy elision

    std::vector<int> vint = f(10);
    // и даже здесь, когда возвращается, по идее, копия, вызовется всего один конструктор!!!
    // парадокс в том, что если бы мы возвращали ссылку на временный объект 
    // (что, в общем-то, запрещено) -- было бы 2 вызова

    S s = S(S(S(S(S(S(2)))))); // вызов всего одного конструктора от 2 (копии не создаются)
    return 0;
}
```
Это возможно, благодаря тому, что все промежуточные объекты -- это `prvalue`. Стандарт гласит: если есть цепочка инициализаций `prvalue`, то можно не создавать (c++17 -- нельзя создавать) всю цепочку, а только последний объект. Это и есть `copy elision`.

Если мы сделаем возврат T&&, то получим `xvalue` -- тут компилятор уже обязан создать временный объект. Это называется `temporarily materialization` (появление временного объекта). 

Ещё `TM` имеет место, когда мы обращаемся к полю rvalue-объекта:
```c++
int x = g(10).p;
```

# RVO 
Return value optimization
```c++
S f(int p) {
    return S(p); // rvo:         1 construct
                 // without rvo: 2 construct
}
```
Named RVO -- оптимизация, когда возвращаем именованный объект. 
```c++
S operator + (const S& a, const S& b) { // named RVO
    S copy = a; // 1 sc
    copy += b;
    return copy; 
    // если сделать return copy += b;
    // то RVO не сработает b будет 2 sc (даже не мув)!!!
}
```
Но это не обязательно произойдёт. Но компилятор сделает move вместо copy, если есть move-конструктор:
```c++
S operator + (S a, const S& b) {
    return a += b;
}
```

