# Литеральные суффиксы
std=c++11
```c++
Class operator ""_cls(type x) {
    return Class(x);
}
```
```c++
type : {uint64_t, const char*, long double}
```
Теперь можно писать штуки вида: `5_cls`,  

# Функторы
`Functional class` -- такой класс, объекты которого можно вызывать, как ф-ю (callable)
```c++
type operator () (type x) {
    return ...
}
```
Часто применяются в качестве компараторов
# Наследование
`public`, `private`, `protected`

`private` -- тот факт, что класс является наследником не может быть использован извне (то есть, запрет внешнему коду обращаться к родительской части). К родительской части можно обращаться только внутри класса и в дружественных функциях **наследника**

`public` -- обращаться извне к родительской части можно

`protected` -- только вы, ваши друзья и ваши наследники могут обращаться к родительской части

**Из наследника нельзя обращаться к приватной части родителя**

`protected` -- доступно мне, моим друзьям, моим наследникам и их друзьям  
Интересность: если поле родителя `protected`, то можно к нему обратиться с помощью friend функции наследника

Второе и последнее отличие классов от структур в том, что тип наследования по умолчанию у классов -- `private`, у структур -- `public`

# Видимость
Сначала идёт проверка имён объектов!!! Это значит, что если есть функции с одинаковыми названиями (только одна в наследнике, а другая -- в родителе), то компилятор **увидит** только функцию **наследника** и если тип неприводим, то будет CE!!! 

Чтобы добавить в область видимости ф-ю с таким же названием: `using Parent::func;`. Притом так меняется модификатор дуступа к `Parent::func` на тот, в котором использован `using`.  
Явный вызов: `son.Parent::name`

Проверки осуществляются в порядке:
1. Имя
2. Тип аргумента
3. Модификатор доступа

Конструкторы неявно не наследуются! Чтобы наследовать, необходим `using`