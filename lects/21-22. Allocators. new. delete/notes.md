# Allocators
Аллокатор -- это менеджер памяти

Вместо того, чтобы постоянно просить ОС выделить маленький кусочек памяти, можно сразу запросить гору памяти, а далее локально её распределять. Именно этим и занимается аллокатор  
То есть, это такой промежуточный слой между ОС и классом -- своя реализация `new` и `delete`

Методы аллокатора:  
`.allocate(numT)` -- выделение памяти  
`.construct(arr+i)` -- типа `placement new`  
`.destroy(arr+i)` -- вызов деструктора для элемента  
`.deallocate(numT)` -- освобождение памяти  
 
## Pool Allocator
Хранит много памяти (точнее, указатель на неё)

Пул -- это область памяти, доступной для аллокатора. Имеет смысл сделать отдельный класс `Pool`, в котором хранится указатель на область памяти. В самом аллокаторе тогда будет указатель на пул. 

Важно: для аллокатора должна быть определена операция сравнения Аллокаторы равны, если то, что было выделено одним аллокатором, можно освободить другим.

## Allocator-Aware container
Проблема: списки, мапы, хэшмапы -- работают не с `<T>`, а с `Node<T>`. Но аллокатор они принимают для `<T>`, как быть? 

Для решения проблемы, C++ обязывает реализовать конструктор Аллокатора от себя самого, но с другим `<T>`. (обёртка -- как декоратор в питоне)

Окей. Но как изменить тип аллокатора (на тот, что нам нужен)? Для этого также надо реализовать `rebind`:
```c++
template <typename U> struct rebind {
    typedef allocator<U> other;
}
...
Allocator::rebind<U>::other alloc;
```

Но что, если аллокатор не реализовал ребайнд (он так-то optional)? Для этого существуют `allocator_traits`:
```c++
using AllocTraits = std::allocator_traits<Alloc>
```

# Перегрузка `new` и `delete`
```
container
 |
\|/
allocator_traits
 |
\|/
allocator
 |
\|/
new, delete
 |
\|/
malloc
``` 
`placement new` переопределить нельзя, но даже если бы и можно было, оператор бы просто возвращал указатель, который был ему подан -- конструктор для указателя вызывает компилятор.

Оператор `new` -- умная обёртка над `malloc`. Но чем он умён:
- вызывает конструктор
- возвращает `T*`, а не `void*` (хотя переопределить нам можно ф-ю, которая возвращает именно `void*`)
- вычисляет количество байт
- если не получилось выделить память, то кидает исключение (а не возвращает NULL, который ещё нужно проверить)
- можно переопределить

Можно определить свои параметры в `new`:
```c++
void* operator new(void *ptr, Args...) {...}
new (args) T(ptr);
```

А вот `delete` нельзя вызывать с таким синтаксисом, придётся костылить (кстати `delete` не вызывает деструктор -- это делает компилятор):
```c++
void operator delete(void *ptr, Args...) {
    std::free(ptr);
}

ptr->~T();
::operator delete(ptr);
```

Интересность: если у нас при конструировании объекта возникло исключение при `new` (то есть, память уже выделеня, но конструктор крашнулся), то компилятор обязуется решить проблемку -- он вызывает `delete`, притом, если есть оператор с кастомными параметрами, вызовет его, если нет -- то стандартный. И утечки памяти не будет

Как запретить объектам типа T создаваться только в куче (но никак не на стеке)? Нужно C++20!!!: 
- сделать деструктор приватным
- определить свой делит
- реализовать внутренний `static void operator delete(T* ptr, std::destroing_delete_t)` и внутри него сначала явно вызвать деструктор, а затем `free()`:
```c++
// этот delete вызывает деструктор!!!
static void operator delete(T* ptr, std::destroing_delete_t) { // std::no_throw_t -- без исключений
    ptr-~T();
    free(ptr)
}
```
