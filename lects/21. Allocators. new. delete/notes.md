# Allocators
Аллокатор -- это менеджер памяти

Вместо того, чтобы постоянно просить ОС выделить маленький кусочек памяти, можно сразу запросить гору памяти, а далее локально её распределять. Именно этим и занимается аллокатор  
То есть, это такой промежуточный слой между ОС и классом -- своя реализация `new` и `delete`

Методы аллокатора:  
`.allocate(numT)` -- выделение памяти  
`.construct(arr+i)` -- типа `placement new`  
`.destroy(arr+i)` -- вызов деструктора для элемента  
`.deallocate(numT)` -- освобождение памяти  
 
## Pool Allocator
Хранит много памяти (точнее, указатель на неё)

Пул -- это область памяти, доступной для аллокатора. Имеет смысл сделать отдельный класс `Pool`, в котором хранится указатель на область памяти. В самом аллокаторе тогда будет указатель на пул. 

Важно: для аллокатора должна быть определена операция сравнения Аллокаторы равны, если то, что было выделено одним аллокатором, можно освободить другим.

## Allocator-Aware container
Проблема: списки, мапы, хэшмапы -- работают не с `<T>`, а с `Node<T>`. Но аллокатор они принимают для `<T>`, как быть? 

Для решения проблемы, C++ обязывает реализовать конструктор Аллокатора от себя самого, но с другим `<T>`. (обёртка -- как декоратор в питоне)

Окей. Но как изменить тип аллокатора (на тот, что нам нужен)? Для этого также надо реализовать `rebind`:
```c++
template <typename U> struct rebind {
    typedef allocator<U> other;
}
...
Allocator::rebind<U>::other alloc;
```

Но что, если аллокатор не реализовал ребайнд (он так-то optional)? Для этого существуют `allocator_traits`:
```c++
using AllocTraits = std::allocator_traits<Alloc>
```

# Перегрузка `new` и `delete`
```
container
 |
\|/
allocator
 |
\|/
allocator_traits
 |
\|/
new, delete
 |
\|/
malloc
``` 
`placement new` переопределить нельзя, но даже если бы и можно было, оператор бы просто возвращал указатель, который был ему подан -- конструктор для указателя вызывает компилятор.

Оператор `new` -- умная обёртка над `malloc`. Но чем он умён:
- вызывает конструктор
- возвращает `T*`, а не `void*` (хотя переопределить нам можно ф-ю, которая возвращает именно `void*`)
- вычисляет количество байт
- если не получилось выделить память, то кидает исключение (а не возвращает NULL, который ещё нужно проверить)
- можно переопределить