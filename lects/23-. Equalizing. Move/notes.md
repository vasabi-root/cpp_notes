# Выравнивание
У инта адрес кратен 4, а у дабла -- 8. Почему? Так удобнее процессору, иначе нужно делать 2 чтения, вместо одного

Начиная с C++11:
максимальное выравнивание (long double) -- но можно расширить для SIMD FMA до 512!!!
```c++
#include <cstddef>
struct alignas(16) Pool { // максимальное выравнивание (long double)
    char arr[100'000];
}; // иначе выравнивание было б по 1 байту

struct alignas(std::max_align_t) Pool { // максимальное выравнивание (long double)
    char arr[100'000];
};
```

Поэтому существует разница между `sizeof()` одной и той же структуры, в которой в разном порядке определены поля. А вот если переменные лежат на стеке (а не единым пластом в структуре) -- то компилятор не обязан из хранить в порядке объявления. 

# Битовые поля
Неважно, какой мы тип пишем при указании битовых полей -- выделится столько, сколько указано после двоеточия (влияет только знаковость). Но размер структуры будет зависеть от типа !!!  `#crunch`
```c++
struct S {
    char c1: 2; // кол-во бит! [-2; 1] 
    char c2: 2;
    // int c3: 2; // из-за инта будет 4 байта сайзоф
    char c3: 3; // так будет 1 байт всего
}
```
У битовых полей нельзя взять адрес -- CE. Битовые поля целесообразно использовать при реализации сетевых протоколов (пакет имеет определённую структуру со строго отведёнными битами)

Move-семантика