# Const-методы
Константные объекты -- это такие, над которыми можно проводить только константные операции.
Константные операции -- это такие, которые не являются неконстнантными.
Неконстантные операции примитивных типов определены стандартом (присваивания, инкремент, декремент, ...).
По умолчанию все методы кастомного типа -- не контантны. Чтобы сделать их констнантными, необходимо добавить слово `const` после закрывающей `)`.
В константном методе компилятор считает все поля константными, также из него нельзя вызывать неконстнантные методы.
`discards qualifiers` (игнор квалификаторов) -- скорее всего, пропущен конст.

`mutable` -- анти_конст для полей класса

Если в поле есть ссылка, то она не станет константной, даже если объект константный!!!

# Дружественные методы и классы
`friend` -- Это анти-private (для функций вне класса, которым доступны private-поля -- но объявление таких ф-й происходит внутри класса). Притом это должна быть именно функция, а не чей-то метод. Либо нужно мутки мутить:
```c++
class C1 {
private:
    int a;
    void f();           // объявление функции
};

class C2 {
private:
    int a;
    friend void C1::f();// объявление этой ф-и дружественной
};

void C1::f() {          // определение
    C2 c2;
    c2.a = 1;
}

int main() {
    C1 c1;
    c1.f()
    return 0;
}
```
`friend`, `mutable`, `reinterpret/const_cast` -- запрпещённые заклинания (можно только в отладке)

# Вывод в поток
Место, где `friend` уместен
std::ostream& operator << (std::ostream &out, )
std::istream& operator >> (std::istream &in, )

# Static-поля и методы
Статик-поля общие для всех объектов класса (можно использовать для подсчёта объектов класса)
По-умному: это такие поля и методы, для обращения к которым не нужно создавать объект класса
`C::f()` 
Можно использовать для `Singletone`
Если статическое поле не является **константой** ИЛИ не является **целочисленным**, то инициализация этого поля происходит ВНЕ класса!
`public` и `private` для статических методов и полей не работают

# Перегрузка приведения типов. Explicit
Конструкторы, деструктор и операторы приведения типов -- единственные методы, для которых не нужно указывать тип возвращаемого значения, ибо он очевиден
`explicit` -- запрещает неявное приведение типов (c++11, до этого можно было помечать только конструкторы)
Конструктор от одного аргумента надо помечать `explicit`
НО:
```c++
if (x) { // НЕ неявный (implicit) каст -- conextual conversion
    ...
}
```