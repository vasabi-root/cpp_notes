# 7. Exceptions

## 7.1. Basic idea and usage
Проблема: какая-то функция внутри стека вызова завершилась неудачно, как отследить это `не по-уродски`?)

C-style способ: возвращать error_code (zero -> ошибки нет). Проблема: мильярд ифов

С++:  
Концепция `throw-try-catch`  
throw ExceptionClass  
try {} catch (ExceptionClass) {}  

```c++
struct Exception
{ std::string error; };

int f(const int &a, const int &b) {
    if (b == 0) throw Exception{"Error: division by zero!"};
    return a / b;
}

void ff() {
    try {
        f(1, 0);
    } catch (Exception e) {
        cout << e.error << endl;
    }
}
```
При этом Exception будет "бросаться" из функции в функцию в глубину стека, пока не встретится соответствующий `catch`  
`f1 -> f2 -> f3 -> f4 -> f5`  
`------|-----------------|`  
`------catch-------------|`  
`------------------------throw`  

Поймать все exceptions -- `catch(...)`

`std::bad_alloc` -- стандартное исключение  
`std::bad_cast` -- стандартное исключение

## 7.2. Difference between exceptions and RE
Не всё, что приводит к RE является исключением  
`Segmentation fault (core dumped)` -- не Exception!!! Это ошибка ОС  
`std::vector<>::at()` -- throwable (std::out_of_range)  
`std::runtime_error` -- один из типов Exception (но это не RE....) -- принимает строку. От него можно наследоваться и перегрузить виртуальный метод `what()` 

Если программа поймала исключение, значит это не RE, если не поймала, то RE

## 7.3. Deep diving into throwing and catching
Exception всегда копируется со стека в другое место (иначе переменная снимется со стека и программа не сможет получить к ней доступ)  
Можно и нужно юзать константные ссылки для ловли исключений  
`throw` внутри `catch` без "того, что нужно кинуть" пустит эту же ошибку на уровень выше (может пригодиться при откатах)

## 7.4. RAII
Решение проблемы утечки памяти при использовании исключений -- деструкторы объектов гарантированно вызываются даже при аварийном завершении -> обернуть `new` в структуру: `std::smart_pointrs` (c++11)

Захват ресурса через оборачивание его в конструктор объекта: RAII (resource acquisition is initiallization)

Если вылетают 2 исключения одновременно -- получаем `aborted core dumped` (и это не поймать)  
Такое возможно, если `throw` есть в деструкторе -- это CodeSmells  
`noexcept` -- спецификатор -- можно пометить функцию (после скобок) и тогда любые попытки бросить исключение в ней приведут к terminate. Можно написать `noexcept(false)`

`std::uncaught_exception()` -- 1, если уже летит исклчение; 0 -- иначе

`function try block` -- если нам надо поймать ошибку, которая возникает внутри списка инициализации конструктора:
```c++
S(int p) try: p(p) {

} catch (...) {

}
```

## 7.5. Exceptions specifications
`noexcept` --  не просто "функция не кидает исключение", а это функция, при запуске которой ничего не пойдёт не так
`noexcept(arg())` -- оператор, который возвращает false, если то, что исполнилось в аргументе:
1. Вызвает new
2. Кидает exception
3. dynamic_cast

## 7.6. Exception-safety
Гарантия того, что программа не сломается при любом возможном выбросе исключения:
1. `Basic gaurantee`: при исключении сохраняется валидность объекта, но неизвестно, в каком состоянии объект будет после выхода из исключения (просто нет UB, утечки памятиб, нарушения инвариантности)
2. `Strong gaurantee`: при исключении происходит откат объекта к состояни, в котором он был до возникновения исключения

STL -- strong gaurantee.