## 8.5. Deque
Дек -- вектор в который можно сделать `push/pop_front`.  
Инициализация элементов начинается с `середины` подмассива.  
Как работать с памятью, когда в одну сторону кончилось место?
```c++
[-----++++++++] // кончилось место
 |
\|/
[---------++++++++--------] // перевыделить массив на новое место?
```
Чтобы было поменьше дефрагментации, дек хранится в памяти как 2 массива (`T*[]` и `T[]`):
```c++
[-----* * * * * * *]
      | | | | | | |
      [][][][][][][]
```
Тогда указатели на элементы не инвалидируются при расширении дека!!! Ведь массивы `T[]` остаются на своих местах  
Но итераторы инвалидируются!!! Итератор дека -- `(T**, size_t)` двойной указатель инвалидируется при смене массива `T*[]`

## 8.6. List

```c++
template <typename T>
class list {
private: 
      struct Node {
            T value;
            Node* next;
            Node* prev;
      }
}
```
Имеет внутри `class Node`. Но не получится иметь указатель на голову списка -- иначе итераторы будут работать некорректно (помним про то, что последний элемент не включается в диапазон элементов, по которым нужно пройтись -- что тогда делать, если список пуст?)

Чтобы решить проблему -- используется фиктивная вершина без `value` (достигается за счёт наследования)

Примечательно, что список имеет свой `sort`, несмотря на то что есть `std::sort`. Дело в том, что `std::sort` требует `random_access_iterator`, коим список не обладает. Но внутренняя реализация тоже имеет сложность O(N log(N)) -- сортировка слиянием списков

## 8.7. Map/set
Мап хранит ключ-значяение и упорядочен по ключам (RB-tree). Сет -- то же самое, только не хранит значение

Принимает 3 шаблонных параметра: `Key, Value, Comparator`, при этом ключ -- const

```c++
using value_type = std::pair<const Ket, Value>;
```

`Exceptions safety`:
- сначала создаём вершину, и только потом содифицируем дерево
- компаратор может кинуть исключение только при вставке (ибо при вращении дерева он не используется, а деструктор не может кидать исключения)

## 8.8. Unordered Map
Хэш-таблица с закрытой адресацией:
```c++
хэши: [ ][ ][ ][ ][ ][ ][ ]
       |              |
       |              ()->()->()
       ()->()->() 
```
Но как реализовать итератор?
Можно пробежаться по всем хешам, но таблица обычно большая, и часть хэшей не используется (тогда для пустой хэш-таблицы это будет очень неэффективно)

Решение -- сделать один список, который хранит в себе указатели `prev` и `next`, а хэш-таблица (хэш-массив) -- это массив `указателей на ноды` списка, которые являются началами цепочки элементов с одним хэшом 
```c++
хэши: [ ][ ][ ][ ][ ][ ][ ]
       |              |
       |             /
       ()->()->()->()->()->()
```

Помимо этого, мы снова имеем фиктивную ноду, которая нужна для корректной работы итератора
```c++
хэши: [ ][ ][ ][ ][ ][ ][ ]
       |              |
       |             /
       ()->()->()->()->()->()
       ^                    |
       +----------()<-------+
```
Чтобы иметь возможность удалять ноду, необходим двусвязный список (так быстрее)

Итераторы могут инвалидироваться, так как при переполнении хеш-таблицы, возникает необходимость рехеширования -- увеличения хэш-массива и пересчёта хэша (занимает $O(n^2)$, если все ноды попали в один хэш; в среднем, имеем $O(n)$)

`bucket` -- цепочка элементов с одним хэшом  
У std::unordered_map есть метод `load_factor`, который возвращает среднее количество элементова в бакетах  
`max_load_factor` -- если load_factor превысит это число (обычно от 0 до 1), то наступает рехэш
`reserve` -- (почти, как в векторе) -- каким будет размер хэш-массива

Параметры хэш-таблицы:
- `Key`, `T`
- `Hash` -- хэш-функтор =`std::hash<Key>`
- `Comparator` на равенство ключей!

Чтобы сделать `std::hash<Key>` рабочим для своего класса, нужно провести специализацию шаблона для этого функтора 