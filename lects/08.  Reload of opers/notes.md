# Конструктор копирования
Существует КП по умолчанию, но он может быть UB:
Есть `shallow`(поверхностное) и `deep`(глубокое) копирование. КП по умолчанию -- shallow.
Поэтому если есть динамические поля, то копия будет просто новым указателем на оригинал. И тогда вызов деструкторов оригинала и копии будет чистить один и тот же участок памяти дважды => UB.
# Делегирующие конструкторы
Class() : Class()

# Агрегатная инициализация
До c++11
Если все поля структуры/класса публичны, то можно фигурными скобками проинициализировать значения этих полей
```c
struct S {
    int a;
    int b;
    std::string s;
};

S s{1, 2, "str"};
```
После с++11 появились `initialize_list`ы

# The Rule Of 3 (TROT)
Если нам потребовался 
1. Нетривиальный конструктор копии ИЛИ 
2. Нетривиальный деструктор ИЛИ
3. Нетривиальный оператор присваивания
То потребуется реализовать их все 3

# Member initializer list
Списки инициализации членов -- способ проинициализировать поля перед входом в конструктор
```c
Class(int a, double d, std::str s) : a(a), d(d), s(s) {}
```
Притом инициализация происходит в том порядке, в которов объявлены поля (мб UB)
Его нельзя комбинировать с делегированием конструкторов (либо либо)

Списки инициализации членов могут переприсваивать константные ссылки
```c
int x = 0;
struct S{
    int &a;
    

    S(int& a) {
        this->a = a; // изменит x
    }
    S(int& a) : a(a) {} // переприсвоит ссылку
}
```
Если сделать так: `S s(5)`, пятёрка проживёт до выхода из конструктора 
А далее -- UB

# Перегрузка операторов
Всегда начинать с операторов присваивания и +=
Ибо если реализовать +, а затем += через +, получится, что += создаёт копию, что неэффективно

Оператор + должен быть двусторонним -- его нужно определять вне класса  

Для того, чтобы неявный каст от примитива к новому типу работал корректно, необходим конструктор, у которого первый параметр -- это тот самый примитивный тип, а все остальные параметры имеют значение по умолчанию

# Copy ellision (c++11)
Complex sum = a+b; // 2 копии, если +: `return copy += z2;`
Но если:
```c
copy += z2;
return copy;
```
то одно!
Это происходит из-за Return Value Optimization (RVO)